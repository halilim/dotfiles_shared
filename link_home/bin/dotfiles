#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Tries to be as idempotent as possible
# Doesn't handle deletions

function setup() {
  printf '%s\n%s\n%s\n%s\n' \
    "$(declare -p DOTFILES)" \
    "$(declare -p DOTFILES_SHARED)" \
    "$(declare -p DOTFILES_INCLUDES)" \
    "$(declare -p DOTFILES_CUSTOM)" \
    > ~/.dotfiles_paths.sh

  sync

  echo_eval '%q/bin/iterm_tab %q omz_install_custom_plugins' "$HOME" "$PWD"
}

function sync() {
  setup_shared_links
  setup_custom_links
  vim_mk_spell
}

function import() {
  local item_path=${1:-''}
  [[ -z $item_path ]] && echo "Usage: $DOTFILES_CMD ${FUNCNAME[0]} <path> [<$(color yellow shared)|custom>]" && return 1
  [[ ! -e $item_path ]] && echo "Does not exist" && return 1

  local relative_path
  relative_path=$(relative_to "$HOME" "$item_path")
  local relative_dir=${relative_path%/*}
  [[ $relative_dir == "$relative_path" ]] && relative_dir=''

  local dotfile_type=${2:-'shared'} dotfile_dir
  case "$dotfile_type" in
    shared) dotfile_dir=$DOTFILES_SHARED ;;
    custom) dotfile_dir=$DOTFILES_CUSTOM ;;
    *) echo >&2 'Unknown dotfile type' && return 1 ;;
  esac

  local dir="$dotfile_dir/link_home/$relative_dir"
  mk_dir "$dir"
  echo_eval_with_sudo home 'mv %q %q' "$item_path" "$dir"

  case "$dotfile_type" in
    shared) setup_shared_links ;;
    custom) setup_custom_links ;;
  esac

  [[ $item_path == $VIM_SPELL/* ]] && vim_mk_spell
}

function setup_shared_links() {
  setup_links "$DOTFILES_SHARED"
}

function setup_custom_links() {
  if [[ -d "$DOTFILES_CUSTOM" ]]; then
    setup_links "$DOTFILES_CUSTOM"
  fi
}

function setup_links() {
  link_recursive "$1"/link_home "$1"/link_home home
}

function link_recursive() {
  local current_source_dir=$1 source_base=$2 type=$3 relative_base target_base target_dir
  relative_base=$(relative_to "$source_base" "$current_source_dir")

  [[ -L "$current_source_dir" ]] && current_source_dir=$(readlink -f "$current_source_dir")

  [[ $relative_base == '.' ]] && relative_base=''

  case "$type" in
    home)
      target_base=$HOME
      ;;
    root)
      target_base=/
      ;;
    *)
      echo >&2 "Unknown link type: $type"
      return 1
      ;;
  esac

  target_dir=$target_base
  [[ $relative_base ]] && target_dir=$target_base/$relative_base

  mk_dir "$target_dir" "$type"

  local dir_source
  # shellcheck disable=SC2044
  for dir_source in $(find_immediate_children "$current_source_dir" d); do
    link_recursive "$dir_source" "$source_base" "$type"
  done

  local file_source
  # shellcheck disable=SC2044
  for file_source in $(find_immediate_children "$current_source_dir" f); do
    link_file "$file_source" "$target_dir" "$type"
  done

  local link_source
  # shellcheck disable=SC2044
  for link_source in $(find_immediate_children "$current_source_dir" l); do
    if [[ -d $(readlink -f "$link_source") ]]; then
      link_recursive "$link_source" "$source_base" "$type"
    else
      link_file "$link_source" "$target_dir" "$type"
    fi
  done
}

function relative_to() {
  grealpath -s --relative-to="$1" "$2"
}

function mk_dir() {
  local dir=$1
  [[ -d "$dir" || $dir == / || $dir == "$HOME" ]] && return 0

  local type=${2:-home}
  [[ -L "$dir" || -f "$dir" ]] && backup "$dir" "$type"
  echo_eval_with_sudo "$type" 'mkdir -p %q' "$dir"
}

function find_immediate_children() {
  local dir=$1 type=$2
  find "$dir" -mindepth 1 -maxdepth 1 -type "$type"
}

function link_file() {
  local source=$1 target_dir=$2 type=$3 source_base
  source_base=$(basename "$source")
  [[ $source_base == '.DS_Store' ]] && return 0

  # macOS no longer accepts symlinks to plist files https://github.com/lra/mackup/issues/1924
  # So for now, we use hard links. Note that they are prone to being replaced by actual files.
  local hard_link=false
  [[ $source == *.plist ]] && hard_link=true

  local target=$target_dir/$source_base

  need_to_link "$source" "$target" "$hard_link" || return 0

  backup "$target" "$type"

  local link_arg=' -s' comment=''
  [[ $hard_link == true ]] && link_arg='' && comment=' # Hard link'

  echo_eval_with_sudo "$type" 'ln%s %q %q%s' "$link_arg" "$source" "$target" "$comment"
}

function need_to_link() {
  local source=$1 target=$2 hard_link=$3

  [[ -e $target ]] || return 0

  if [[ $hard_link == false ]]; then
    [[ $(readlink -f "$target") != $(readlink -f "$source") ]]
  else
    local inode_count
    # shellcheck disable=SC2012
    inode_count=$(ls -i "$target" "$source" | cut -d ' ' -f 1 | uniq | wc -l | tr -d '[:space:]')
    [[ $inode_count == 2 ]]
  fi
}

function backup() {
  local file=$1
  [[ ! -L "$file" && ! -f "$file" && ! -d "$file" || $file == / || $file == "$HOME" ]] && return 0

  [[ -L "$file" && ! -e "$file" ]] && echo_eval_with_sudo "$type" 'rm %q # Broken link' "$file" && return

  local type=$2
  echo_eval_with_sudo "$type" 'mv %q{,.bak.%q}' "$file" "$(date +'%s')"
}

function echo_eval_with_sudo() {
  local type=$1
  shift
  cmd=("$@")
  # NOTE: If this gets migrated to Zsh, change 0 to 1
  [[ "$type" == 'root' ]] && cmd[0]="sudo ${cmd[0]}"
  echo_eval "${cmd[@]}"
}

function vim_mk_spell() {
  # TODO: Is this the correct process, or should multiple files for a locale be merged? Check Vim
  local force=${1:-false} file files=()
  for file in "$VIM_SPELL"/*.dic; do
    [[ $force == true || ! $(find $VIM_SPELL -name "$(basename "$file")*.spl" -print -quit) ]] && files+=("$file")
  done

  local num_files=${#files[@]}
  [[ $num_files -eq 0 ]] && return 0

  # TODO: This doesn't seem to be working in Vim. Try word: 'dotfiles' https://vi.stackexchange.com/a/15053
  echo_eval "vim +'$(printf 'mkspell! %%q | %.0s' $(seq 1 "$num_files"))q'" "${files[@]}"
}

export DOTFILES_CMD
DOTFILES_CMD=$(basename "$0")

export VIM_SPELL=~/.vim/spell

export DOTFILES
DOTFILES="$(dirname "$(dirname "$(dirname "$(dirname "$(realpath "$0")")")")")"
export DOTFILES_SHARED=$DOTFILES/shared
export DOTFILES_INCLUDES=$DOTFILES_SHARED/includes
export DOTFILES_CUSTOM=$DOTFILES/custom

# shellcheck disable=SC1091
. "$DOTFILES_INCLUDES"/functions.sh

case "${1:-''}" in
  setup) setup ;;
  sync) sync ;;
  import) import "${2:-}" "${3:-}" ;;
  vim_mk_spell) vim_mk_spell true ;;
  *) echo "Usage: $DOTFILES_CMD <setup|sync|import|vim_mk_spell>" ;;
esac
