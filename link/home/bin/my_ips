#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# shellcheck disable=SC1091
. "$HOME"/.dotfiles_bootstrap.sh
# shellcheck disable=SC1091
. "$DOTFILES_INCLUDES"/bash_shared.sh

# https://www.nerdfonts.com/cheat-sheet
readonly BRIDGE_ICON=󰘘
readonly ETHERNET_ICON=󰈀
readonly ETHERNET_IP_ICON=󱂇
readonly WIFI_ICON=
readonly WIFI_IP_ICON=󰑩
readonly ROUTER_ICON=󱇢
readonly EXTERNAL_ICON=
readonly ARROW_ICON=
readonly TUNNEL_ICON=󱠽

function get_field() {
  local output=$1 label=$2 value
  value=$(echo "$output" | rg --multiline --only-matching "^\s*$label:\s*(\S+)" -r '$1' --color=never)
  if [[ $value == 'none' ]]; then
    echo ''
  else
    echo "$value"
  fi
}

export ROUTED_DEVICE
route_output=$(route get 1.1.1.1)
ROUTED_DEVICE=$(get_field "$route_output" 'interface')

export ROUTED_DEVICE_FOUND
ROUTED_DEVICE_FOUND=''

function get_external_ip() {
  local ip=$1
  # TODO: might cache proxies, see my_external_ip
  dig @ns1.google.com TXT o-o.myaddr.l.google.com +short -b "$ip" | tr -d '"'
}

function print_header() {
  local icon=$1 name=$2 device=$3 header_color

  if [[ $device == "$ROUTED_DEVICE" ]]; then
    ROUTED_DEVICE_FOUND=1
    header_color='green-bold'
  else
    header_color='white-bold'
  fi

  local name_device="$name"
  if [[ $device != "$name" ]]; then
    name_device="$name ($device)"
  fi

  color $header_color "$icon  $name_device"
}

function print_icon() {
  local icon=$1
  color white-bold "$icon"
}

function print_ip() {
  local icon=$1 ip=$2
  if [[ ! $ip ]]; then
    return 0
  fi

  printf ' %s  %s %s' "$ARROW_ICON" "$(print_icon "$icon")" "$ip"
}

function print_ip_line() {
  local ip_icon=$1 ip=$2 networksetup_output=$3 router_label=$4
  if [[ ! $ip ]]; then
    return 0
  fi

  printf '%s %s' "$(print_icon "$ip_icon")" "$ip"

  if [[ $networksetup_output ]]; then
    local router_ip external_ip
    router_ip=$(get_field "$networksetup_output" "$router_label")
    if [[ $router_ip ]]; then
      print_ip "$ROUTER_ICON" "$router_ip"
      external_ip=$(get_external_ip "$ip")
      print_ip "$EXTERNAL_ICON" "$external_ip"
    fi
  fi

  printf '\n'
}

function print_network() {
  local device=$1 name=$2 networksetup_output='' ipv4=${IPV4:-} ipv6=${IPV6:-}

  if [[ $name != "$device" ]]; then
    networksetup_output=$(networksetup -getinfo "$name")
    ipv4=$(get_field "$networksetup_output" "IP address")
    ipv6=$(get_field "$networksetup_output" "IPv6 IP address")
  fi

  if [[ ! $ipv4 && ! $ipv6 ]]; then
    return 0
  fi

  local icon ip_icon

  case $name in
    *Bridge*) icon=$BRIDGE_ICON ip_icon=$ETHERNET_IP_ICON ;;
    *\ LAN | *\ ethernet) icon=$ETHERNET_ICON ip_icon=$ETHERNET_IP_ICON ;;
    *Wi-Fi*) icon=$WIFI_ICON ip_icon=$WIFI_IP_ICON ;;
    *utun*) icon=$TUNNEL_ICON ip_icon=$ROUTER_ICON ;;
    *) icon='?' ip_icon=$ROUTER_ICON ;;
  esac

  print_header "$icon" "$name" "$device"
  print_ip_line $ip_icon "$ipv4" "$networksetup_output" 'Router'
  print_ip_line $ip_icon "$ipv6" "$networksetup_output" 'IPv6 Router'
}

# From network_switcher
networks=$(networksetup -listnetworkserviceorder | tail -n +2)
# Loop over networks instead of ifconfig lines to get the correct order (i.e. the active network first)
while [ "$networks" != '' ]; do
  networks="${networks#*\(}"  # '*) Service 1\n...'
  number=${networks%%\)*}     # '*'
  networks="${networks#*\) }" # 'Service 1\n...'
  name=${networks%%$'\n'*}    # 'Service 1'

  networks="${networks#*$'\n'*Device: }" # 'en0)\n...'
  device=${networks%%\)*}                # 'en0'
  networks="${networks#*\)}"             # '' (tail call for the final network, since there's no \n\n anymore)
  networks="${networks#*$'\n\n'}"        # '(2) Service 2\n...'

  [[ $number == '*' || ! $device ]] && continue

  print_network "$device" "$name"
done

if [[ ! $ROUTED_DEVICE_FOUND ]]; then
  IPV4="$(get_field "$route_output" 'gateway')" print_network "$ROUTED_DEVICE" "$ROUTED_DEVICE"
fi
